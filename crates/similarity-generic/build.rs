use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Get the output directory
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("language_configs.rs");
    
    // Read all JSON files from language_configs directory
    let configs_dir = Path::new("language_configs");
    
    let mut output = String::new();
    output.push_str("// Auto-generated by build.rs\n\n");
    output.push_str("use once_cell::sync::Lazy;\n");
    output.push_str("use std::collections::HashMap;\n\n");
    
    // Generate a static HashMap of language configs
    output.push_str("pub static LANGUAGE_CONFIGS: Lazy<HashMap<&'static str, &'static str>> = Lazy::new(|| {\n");
    output.push_str("    let mut map = HashMap::new();\n");
    
    if configs_dir.exists() {
        for entry in fs::read_dir(configs_dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            
            if path.extension().and_then(|s| s.to_str()) == Some("json") {
                let file_name = path.file_stem().unwrap().to_str().unwrap();
                let content = fs::read_to_string(&path).unwrap();
                
                // Escape the JSON content for inclusion in Rust code
                let escaped_content = content
                    .replace('\\', "\\\\")
                    .replace('"', "\\\"")
                    .replace('\n', "\\n");
                
                output.push_str(&format!(
                    "    map.insert(\"{}\", \"{}\");\n",
                    file_name, escaped_content
                ));
            }
        }
    }
    
    output.push_str("    map\n");
    output.push_str("});\n");
    
    // Write the generated code
    fs::write(&dest_path, output).unwrap();
    
    // Tell Cargo to rerun if any config file changes
    println!("cargo:rerun-if-changed=language_configs");
}